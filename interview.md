# Junior

## Общие

1. Что такое DevOps?
	
	**DevOps** — это набор *методик*, *инструментов* и *философия культуры*, которые позволяют автоматизировать и интегрировать между собой процессы команд разработки ПО и ИТ‑команд. Особое внимание в DevOps уделяется расширению возможностей команд, их взаимодействию и сотрудничеству, а также автоматизации технологий.
	Термин DevOps является комбинацией двух слов — development (разработка) и operations (эксплуатация) — и отражает процесс объединения этих практик в один непрерывный процесс.
	

2. Вы набираете *google.com* в браузере. Расскажите как можно подробнее, что происходит в это время?
	
	1. Enter **_google.com_**
	2. Проверка списка «предзагруженных HSTS (_HTTP Strict Transport Security_)». Это список сайтов, которые требуют, чтобы к ним обращались только по HTTPS.
	3. Если нужный сайт есть в этом списке, то браузер отправляет ему запрос через HTTPS вместо HTTP. В противном случае, начальный запрос посылается по HTTP. (При этом сайт может использовать политику HSTS, но не находиться в списке HSTS — в таком случае на первый запрос по HTTP будет отправлен ответ о том, что необходимо отправлять запросы по HTTPS. Однако это может сделать пользователя уязвимым к downgrade-атакам — чтобы этого избежать, в браузеры и включают список HSTS).
	4. **Определение DNS**
		- Браузер проверяет наличие домена в своём кэше.
		- Если домена там нет, то браузер вызывает библиотечную функцию _**gethostbyname**_ (отличается в разных ОС) для поиска нужного адреса.
		- Прежде, чем искать домен по DNS _**gethostbyname**_ пытается найти нужный адрес в файле _**hosts**_ (его расположение отличается в разных ОС).
		- Если домен нигде не закэширован и отсутствует в файле **_hosts_**, _**gethostbyname**_ отправляет запрос к сетевому DNS-серверу. Как правило, это локальный роутер или DNS-сервер Интернет-провайдера.
		- Если DNS-сервер находится в той же подсети, то ARP-запрос отправляется этому серверу.
		- Если DNS-сервер находится в другой подсети, то ARP-запрос отправляется на IP-адрес шлюза по умолчанию (default gateway).
		- _Порт 53 открывается для отправки UDP-запроса к DNS-серверу (если размер ответа слишком велик, будет использован TCP)._
		- _Если локальный или на стороне провайдера DNS-сервер «не знает» нужный адрес, то запрашивается рекурсивный поиск, который проходит по списку вышестоящих DNS-серверов, пока не будет найдена SOA-запись, а затем возвращается результат._
	5. Открытие сокета. Когда браузер получает IP-адрес конечного сервера, то он берёт эту информацию и данные об используемом порте из URL (80 порт для HTTP, 443 для HTTPS) и осуществляет вызов функции `socket` системной библиотеки и запрашивает поток TCP сокета — `AF_INET` и `SOCK_STREAM`.
	6. **TLS handshake**
		- Клиентский компьютер отправляет сообщение `ClientHello` серверу со своей версией протокола [TLS](https://ru.wikipedia.org/wiki/TLS), списком поддерживаемых алгоритмов шифрования и методов компрессии данных.
		- Сервер отвечает клиенту сообщением `ServerHello`, содержащим версию TLS, выбранный метод шифрования, выбранные методы компрессии и публичный сертификат сервиса, подписанный центром сертификации. Сертификат содержит публичный ключ, который будет использоваться клиентом для шифрования оставшейся части процедуры «рукопожатия» (`handshake`), пока не будет согласован симметричный ключ.
		- Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации. Если сертификат подписан центром из списка, то серверу можно доверять, и клиент генерирует строку псевдослучайных байтов и шифрует её с помощью публичного ключа сервера. Эти случайные байты могут быть использованы для определения симметричного ключа.
		- Сервер расшифровывает случайные байты с помощью своего секретного ключа и использует эти байты для генерации своей копии симметричного мастер-ключа.
		- Клиент отправляет серверу сообщение `Finished`, шифруя хеш передачи с помощью симметричного ключа.
		- Сервер генерирует собственный хеш, а затем расшифровывает полученный от клиента хеш, чтобы проверить, совпадёт ли он с собственным. Если совпадение обнаружено, сервер отправляет клиенту собственный ответ `Finished`, также зашифрованный симметричным ключом.
		- После этого TLS-сессия передаёт данные приложения (HTTP), зашифрованные с помощью подтверждённого симметричного ключа.
		1. **Протокол HTTP**. Если клиент использует HTTP-протокол и не поддерживает SPDY (используемый в браузерах от Google), то отправляет серверу запрос следующей формы:
		
		```
		GET / HTTP/1.1
		Host: google.com
		Connection: close
		[другие заголовки]
		```
		
		где `[другие заголовки]` — это серия пар «ключ: значение», разбитых переносом строки. (Здесь предполагается, что в использованном браузере нет никаких ошибок, нарушающих спецификацию HTTP. Также предполагается, что браузер использует `HTTP/1.1`, в противном случае он может не включать заголовок `Host` в запрос и версия, отданная в ответ на GET-запрос может быть `HTTP/1.0` или `HTTP/0.9`).
		`HTTP/1.1` определяет опцию закрытия соединения («close») для отправителя — с её помощью происходит уведомление о закрытии соединения после завершения ответа. К примеру:
		
		> [!tip] Connection: close
		  
		Приложения `HTTP/1.1`, которые не поддерживают постоянные соединения, обязаны включать опцию «close» в каждое сообщение.
		После отправки запроса и заголовков, браузер отправляет серверу единичную пустую строку, сигнализируя о том, что содержимое сообщения закончилось.
		Сервер отвечает специальным кодом, который обозначает статус запроса и включает ответ следующей формы:
		
		```
		200 OK
		[заголовки ответа]
		```
		
		После этого посылается пустая строка, а затем оставшийся контент HTML-страницы [www.google.com](http://www.google.com/). Сервер может затем закрыть соединение, или, если того требуют отправленные клиентом заголовки, сохранять соединение открытым для его использования следующими запросами.
		Если HTTP-заголовки отправленные веб-браузером включают информацию, которой серверу достаточно для определения версии файла, закэшированного в браузере и этот файл не менялся со времени последнего запроса, то ответ может принять следующую форму:
		
		```
		304 Not Modified
		[заголовки ответа]
		```
		
		и, соответственно, клиенту не посылается никакого контента, вместо этого браузер «достаёт» HTML из кэша.
		После разбора HTML, браузер (и сервер) повторяет процесс загрузки для каждого ресурса (изображения, стили, скрипты, favicon.ico и так далее), на который ссылается HTML-страница, но при этом изменяется адрес каждого запроса c `GET / HTTP/1.1` на `[](http://www.google.com/)GET /$(относительный URL ресурса www.google.com) HTTP/1.1`.
		Если HTML ссылается на ресурс, размещённый на домене, отличном от google.com, то браузер возвращается к шагам, включающим разрешение доменного имени, а затем заново проходит процесс до текущего состояния, но уже для другого домена. Заголовок `Host` в запросе вместо google.com будет установлен на нужное доменное имя.
	

3. Как работает HTTPS?
	
	HTTPS — это не совсем протокол. Это расширение HTTP-протокола — объединение двух протоколов: HTTP и SSL или HTTP и TLS. 
	Протоколы **TLS** (Transport Layer Security) и **SSL** (Secure Socket Layer) — криптографические. Это значит, что они позволяют шифровать данные, в нашем случае те, что передаются между браузером и сервером. Расшифровать эти данные могут только сервер и браузер, для всех остальных это будет набор нечитаемых символов.
	
	> [!tip] TLS основан на SSL, но второй уже устарел, и вместо него используют TLS.
	
	У ресурса/сайта, поддерживающего HTTPS, есть SSL/TLS-сертификат, который выдается центром сертификации. Если у ресурса в адресной строке есть зеленый замок, соединение с ним защищено.
	
	> [!tip] Посмотреть информацию о сертификате и его подлинности можно, нажав на значок.
	
	Как правило, SSL/TLS-сертификат — это подтверждение, что ресурс настоящий. Но могут быть исключения: сертификат может быть выдан легитимным центром на фишинговый сайт. В таком случае важно совпадение CN в сертификате с доменным именем сайта и уверенность пользователя в этом имени.
	Перед тем как запустить HTTP-соединение, браузер обращается к серверу, чтобы наладить защищенное соединение. Сервер отправляет копию сертификата безопасности в ответ.
	Браузер проверяет данные по своим спискам доверенных центров (список есть в каждом браузере), проверяет совпадение CN с доменным именем, даты выпуска и срока окончания сертификата, отсутствие в CRL, поддерживаемые алгоритмы, наличие издателя в списке доверенных корневых сертификатов и в списке доверенных издателей. В случае проблем на любой из этих проверок сертификат считается не валидным.
	Если все хорошо, то браузер считает ресурс безопасным: они выбирают алгоритм шифрования, обмениваются ключом шифрования и потом данными по протоколу HTTP.
	Схематически это выглядит так:
	
	> [!info]- PNG
	> 
	> ![https,tls,ssl](https.tls-ssl.png)
	
	> [!info]- MERMAID
	> 
	> ```mermaid
	> sequenceDiagram
	> 	participant C as Client
	> 	participant S as Server
	> 	C->>+S: 1. Приветствие клиента
	> 	Note right of C: Поддерживаемые шифры
	> 	Note right of C: Случайные номера
	> 	Note right of C: ID сессии
	> 	Note right of C: Индикация имени сервера (SNI)
	> 	S-->>+C: 2. Приветствие сервера
	> 	S->>+C: 3. Сертификаты сервера
	> 	S->>+C: 4. Завершение приветствия сервера
	> 	Note left of S: Выбранные шифры
	> 	Note left of S: Случайные номера
	> 	Note left of S: ID сессии
	> 	Note left of S: SNI (пустой)
	> 	C->>+S: 6. Обмен ключами
	> 	Note over S,C: Зашифрованный предварительный секрет
	> 	Note over S,C: 6. Генерация ключа
	> 	C->>+S: 7. Сообщение Change Cipher Spec.
	> 	C->>+S: 8. Finished
	> 	S->>+C: 7. Сообщение Change Cipher Spec.
	> 	S->>+C: 9. Finished
	> 	Note over S,C: (ВЫШЕ) протокол рукопожатия
	> 	Note over S,C: (НИЖЕ) протокол записи
	> 	S->C: Данные приложения
	> ```
	

4. Объясните концепцию Infrastructure as Code (IaC), зачем это нужно и какие проблемы решает?
	
	 Infrastructure as Code (IaC) — это подход к автоматизации и управлению инфраструктурой через использование кода. Вместо ручной настройки и обслуживания инфраструктуры, IaC позволяет разработчикам и системным администраторам управлять инфраструктурой с помощью программного кода, выполняя автоматическую установку, конфигурацию и развертывание через специализированные инструменты, такие как Ansible, Terraform, Puppet, Chef и т.д.
	 Основная идея IaC заключается в том, что инфраструктура управляется и модифицируется таким же образом, как и код приложения. Это позволяет реализовать принципы DevOps: консистентность (Согласованность данных), повторяемость и автоматизацию, а также обеспечивает более быстрое и надежное внедрение изменений в инфраструктуру.
	 Существует несколько подходов к реализации IaC:
	- **Декларативный подход**. Инфраструктура описывается в виде конфигурационных файлов, которые указывают желаемое состояние системы, а инструменты IaC берут на себя всю остальную работу: развертывание виртуальной машины или контейнера, установка и настройка необходимого программного обеспечения, управление версиями и т.д. Главный недостаток декларативного подхода заключается в том, что для его настройки и управления обычно требуется опытный администратор. Terraform и CloudFormation являются примерами популярных инструментов, использующих декларативный подход.
	- **Императивный подход**. Инфраструктура определяется путем применения команд и скриптов для создания и управления ресурсами. Несмотря на то, что по мере масштабирования инфраструктуры при использовании такого подхода может потребоваться проделать больше работы, системным администраторам может быть проще с ним разобраться, поскольку они могут использовать уже имеющиеся сценарии настройки. Примерами таких инструментов являются Ansible и Chef.
	- **Гибридный подход**. Комбинация декларативного и императивного подходов, где описание инфраструктуры может включать в себя и декларативные файлы, а также императивные команды для настройки определенных частей инфраструктуры.
	

## Linux

5. Опишите общую архитектуру операционной системы.

6. Опишите основное предназначение операционной системы.

7. Зачем нужны файловые системы? Какие существуют?
	
	Файловая система — это структура, используемая операционной системой для организации и управления файлами на устройстве хранения, например на жестком диске, твердотельном накопителе (SSD) или USB-накопителе. Она определяет правила хранения и организации данных на устройстве хранения, а также доступа к ним. Различные файловые системы имеют разные характеристики и часто относятся к определенным операционным системам или устройствам.
	Некоторые из распространенных файловых систем, их преимущества и недостатки:
	
	> [!info] **FAT (таблица размещения файлов), FAT16, FAT32** — одна из старейших и простейших файловых систем. Первоначально она была разработана для MS-DOS и до сих пор используется во многих съемных устройствах хранения. Две основные версии этой системы — FAT16 и FAT32. FAT использует таблицу размещения файлов для отслеживания расположения файлов на диске. Однако в ней отсутствуют некоторые дополнительные функции, такие как права доступа к файлам и ведение журнала. В результате она менее подходит для современных операционных систем. FAT 16 была представлена в 1987 году вместе с DOS 3.31, а FAT32 внедрена в Windows 95 OSR2 (MS-DOS 7.1) в 1996 году.
	> 
	> > [!success]- Преимущества:
	> > - **Простота.** Простота упрощает реализацию и использование, благодаря чему эта файловая система подходит для устройств с ограниченными ресурсами или требованиями к совместимости.
	> > - **Восстановление данных.** Благодаря простой структуре файловые системы FAT относительно легко восстанавливаются в случае повреждения или случайного удаления данных.
	> > - **Совместимость:** Изначально обеспечивает запись и чтение файлов в операционных системах Windows, MacOS и Linux без необходимости использования стороннего программного обеспечения.
	>
	> > [!bug]- Недостатки:
	> > - **Фрагментация.** Фрагментация происходит, когда данные в файле разбросаны по разным частям диска, что приводит к снижению производительности. Для оптимизации производительности диска требуется регулярная дефрагментация.
	> > - **Отсутствие расширенных функций.** В самой новой версии FAT32 отсутствуют некоторые расширенные функции, имеющиеся в других файловых системах. Она не поддерживает разрешения безопасности на уровне файлов, ведение журнала, шифрование или сжатие.
	> > - **Ограничения на имена томов.** Имена томов для FAT16 и FAT32 не могут содержать больше 11 символов и не могут включать в себя большинство специальных символов.
	> > - **Ограничения на имена файлов.** Имена файлов в файловой системе FAT16 не могут превышать 8.3 символов. Это означает 8 символов плюс 3 символа расширения файла.
	
	> [!info] **exFAT (расширенная таблица размещения файлов)** — это файловая система, представленная компанией Microsoft как улучшенный вариант FAT32. Она устраняет некоторые ограничения FAT32, позволяя использовать файлы большего размера и повышая производительность. exFAT обычно используется для съемных устройств хранения, таких как внешние твердотельные накопители, жесткие диски и карты памяти SD, поскольку обеспечивает совместимость с различными операционными системами. Была впервые представлена в 2006 году как часть Windows CE 6.0.
	>
	> > [!success]- Преимущества:
	> > - **Поддержка большого размера файлов и разделов.** exFAT поддерживает гораздо большие размеры файлов и разделов по сравнению с файловыми системами FAT. Она может работать с файлами размером более 4 ГБ, благодаря чему подходит для хранения больших медиафайлов или образов дисков.
	> > - **Эффективное использование дискового пространства.** В exFAT улучшено использование дискового пространства по сравнению со старыми файловыми системами FAT. В ней используются меньшие размеры кластеров, что уменьшает объем неиспользуемого дискового пространства для небольших файлов.
	> > - **Совместимость:** Изначально обеспечивает запись и чтение файлов в операционных системах Windows и MacOS без необходимости использования стороннего программного обеспечения.
	>
	> > [!bug]- Недостатки:
	> > - **Ограниченная поддержка метаданных.** В exFAT отсутствуют некоторые дополнительные функции, которые есть в других современных файловых системах. Она не поддерживает разрешения безопасности на уровне файлов, ведение журнала и шифрование на уровне файловой системы.
	> > - **Фрагментация.** Как и файловые системы FAT, exFAT по-прежнему подвержена фрагментации. При создании, изменении и удалении файлов может возникнуть фрагментация, что со временем приведет к снижению производительности.
	
	> [!info] **NTFS (файловая система Windows NT)** — это файловая система по умолчанию, используемая операционными системами на базе Windows NT, начиная с 1993 года с Windows NT 3.1 и вплоть до Windows 11 включительно. Она предлагает расширенные функции, такие как права доступа к файлам, шифрование, сжатие и ведение журнала. NTFS поддерживает большие размеры файлов и разделов, благодаря чему подходит для современных устройств хранения данных. Однако имеет ограниченную совместимость с операционными системами, отличными от Windows.
	> 
	> > [!success]- Преимущества:
	> > - **Безопасность и права доступа.** NTFS обеспечивает надежную модель безопасности с разрешениями на уровне файлов. Она позволяет устанавливать разрешения для отдельных файлов и папок, контролируя права доступа для пользователей и групп.
	> > - **Поддержка TRIM на твердотельных накопителях (SSD).** TRIM информирует SSD-накопитель о неиспользуемых данных, что позволяет стереть их и подготовить место для записи в будущем. TRIM включается по умолчанию, если выбрано сохранение производительности файловой системы NTFS.
	>
	> > [!bug]- Недостатки:
	> > - **Сбои и восстановление диска.** Хотя NTFS разработана с расчетом на надежность, сбои диска все же могут возникать. При обнаружении сбоев диска восстановление NTFS может занять много времени и потребовать специальных инструментов.
	> > - **Фрагментация.** Со временем файловые системы NTFS могут стать фрагментированными, особенно при создании, изменении и удалении файлов. Фрагментация может привести к снижению производительности, поскольку системе приходится обращаться к разбросанным фрагментам файлов.
	
	> [!info] **APFS (файловая система Apple)** — это файловая система, разработанная Apple для macOS, iOS и других устройств Apple. Она предназначен для оптимизации производительности и совместимости с аппаратным и программным обеспечением Apple. APFS включает такие функции, как клонирование, шифрование на уровне файлов и улучшенную производительность на твердотельных накопителях. Она была представлена вместе с macOS 10.13 в 2017 году.
	>
	> > [!success]- Преимущества:
	> > - **Улучшенная производительность.** APFS обеспечивает улучшенную производительность по сравнению со своим предшественником, HFS+. В ней используются такие методы, как копирование при записи, совместное использование пространства и оптимизированная обработка метаданных, для повышения скорости чтения и записи.
	> > - **Безопасность данных.** APFS включает встроенные функции обеспечения целостности данных, такие как контрольные суммы для метаданных и содержимого файлов. Это помогает обнаруживать и предотвращать повреждение данных. Она также поддерживает встроенное шифрование, позволяя пользователям шифровать свои данные на этом уровне, что повышает безопасность и защищает конфиденциальную информацию.
	>
	> > [!bug]- Недостатки:
	> > - **Поддержка TRIM на твердотельных накопителях (SSD).** Хотя APFS поддерживает команды trim для SSD-накопителей, это может быть не столь эффективно по сравнению с другими файловыми системами. TRIM отвечает за оптимизацию производительности и срока службы твердотельных накопителей за счет эффективного управления блоками данных.
	> > - **Поддержка стороннего программного обеспечения.** Некоторое более старое стороннее программное обеспечение или утилиты могут не полностью поддерживать APFS или иметь ограничения при работе с отформатированными накопителями. Перед переходом на файловую систему APFS важно убедиться, что важное программное обеспечение или инструменты совместимы с ней.
	> > - Файловая система APFS не позволяет чтение или запись на ПК с Windows без стороннего программного обеспечения.
	
	> [!info] **HFS, HFS+ (иерархическая файловая система)** — это файловая система, изначально использовавшаяся на компьютерах Apple. Впоследствии ее заменили системы HFS+ и APFS. HFS использует иерархическую структуру каталогов и поддерживает такие функции, как метаданные и ветви ресурсов для хранения дополнительной информации о файлах. Она совместима с системами Mac прежних версий. HFS была представлена в 1986 году вместе с System 2.1 для Mac Plus. HFS+ была внедрена в 1998 году вместе с Mac OS 8.1. Постепенно ее заменила APFS, вышедшая в 2019 году вместе с macOS 10.15.
	>
	> > [!success]- Преимущества:
	> > - **Простота.** HFS имеет относительно простую и понятную структуру, что упрощает ее внедрение и понимание.
	> > - **Поддержка метаданных.** В HFS была представлена концепция метаданных, позволяющих хранить дополнительную информацию о файлах, такую как даты создания и изменения, тип файла и ветви ресурсов.
	>
	> > [!bug]- Недостатки:
	> > - **Отсутствие расширенных функций.** В HFS отсутствуют некоторые дополнительные функции, которые есть в более современных файловых системах. Она не поддерживает разрешения безопасности на уровне файлов, ведение журнала, сжатие файлов или шифрование.
	> > - **Ограниченная поддержка размеров файлов и разделов.** В HFS есть ограничения на размеры файлов и разделов. Она может работать с файлами размером до 2 ГБ и поддерживает разделы размером до 2 ТБ.
	> > - **Файлы повреждаются за пределами файловой системы.** При копировании некоторых типов файлов (особенно файлов без расширений) из HFS или HFS + в большинство других файловых систем, перечисленных здесь, они не будут включать ветвь ресурсов. В результате скопированные файлы будут недоступны для чтения, если будут включены обратно в HFS, если только они не были изначально заархивированы в формате .zip или .sit.
	
	> [!info] **Ext4 (четвертая расширенная файловая система)** — широко используемая файловая система в операционной системе Linux. Она является преемником Ext3 и предлагает несколько улучшений с точки зрения производительности, масштабируемости и надежности. Ext4 является файловой системой по умолчанию для многих дистрибутивов Linux. Впервые была представлена в 2003 году.
	>
	> > [!success]- Преимущества:
	> > - **Ведение журнала.** Журнал отслеживает изменения до того, как они будут зафиксированы на накопителе, что позволяет быстрее восстанавливать данные в случае сбоев питания или системных сбоев. Это снижает риск повреждения данных и обеспечивает согласованность файловой системы.
	> > - **Увеличенный размер файлов и разделов.** Ext4 поддерживает значительно большие размеры файлов и разделов по сравнению со своими предшественниками.
	>
	> > [!bug]- Недостатки:
	> > - **Фрагментация.** Как и большинство файловых систем, Ext4 подвержена фрагментации. С течение времени при создании, изменении и удалении файлов может возникнуть фрагментация, что ведет к снижению производительности.
	> > - **Ограниченная масштабируемость.** Хотя Ext4 поддерживает большие размеры файлов и разделов по сравнению со своими предшественниками, у нее есть определенные ограничения, когда дело доходит до экстремальной масштабируемости.
	

8. В чем разница между виртуализацией и контейнеризацией?
	
	![evolution to container](Container_Evolution.svg)
	
	**Традиционная эра развертывания:** Ранее организации запускали приложения на физических серверах. Не было никакого способа определить границы ресурсов для приложений на физическом сервере, и это вызвало проблемы с распределением ресурсов. Например, если несколько приложений выполняются на физическом сервере, могут быть случаи, когда одно приложение будет занимать большую часть ресурсов, и в результате чего другие приложения будут работать хуже. Решением этого было запустить каждое приложение на другом физическом сервере. Но это не масштабировалось, поскольку ресурсы использовались не полностью, из-за чего организациям было накладно поддерживать множество физических серверов.
	
	**Эра виртуального развертывания:** В качестве решения была представлена виртуализация. Она позволила запускать несколько виртуальных машин (ВМ) на одном физическом сервере. Виртуализация изолирует приложения между виртуальными машинами и обеспечивает определенный уровень безопасности, поскольку информация одного приложения не может быть свободно доступна другому приложению.
	Виртуализация позволяет лучше использовать ресурсы на физическом сервере и обеспечивает лучшую масштабируемость, поскольку приложение можно легко добавить или обновить, кроме этого снижаются затраты на оборудование и многое другое. С помощью виртуализации можно превратить набор физических ресурсов в кластер одноразовых виртуальных машин.
	Каждая виртуальная машина представляет собой полноценную машину, на которой выполняются все компоненты, включая собственную операционную систему, поверх виртуализированного оборудования.
	
	**Эра контейнеров:** Контейнеры похожи на виртуальные машины, но у них есть свойства изоляции для совместного использования операционной системы (ОС) между приложениями. Поэтому контейнеры считаются легкими. Подобно виртуальной машине, контейнер имеет свою собственную файловую систему, процессор, память, пространство процесса и многое другое. Поскольку они не связаны с базовой инфраструктурой, они переносимы между облаками и дистрибутивами ОС.	
	

9. В чем преимущества контейнеров?
	
	Контейнеры стали популярными из-за таких дополнительных преимуществ как:	
	- Гибкое создание и развертывание приложений: простота и эффективность создания образа контейнера по сравнению с использованием образа виртуальной машины.
	- Непрерывная разработка, интеграция и развертывание: обеспечивает надежную и частую сборку и развертывание образа контейнера с быстрым и простым откатом (благодаря неизменности образа).
	- Разделение задач между Dev и Ops: создавайте образы контейнеров приложений во время сборки/релиза, а не во время развертывания, тем самым отделяя приложения от инфраструктуры.
	- Наблюдаемость охватывает не только информацию и метрики на уровне ОС, но также информацию о работоспособности приложений и другие сигналы.
	- Идентичная окружающая среда при разработке, тестировании и релизе: на ноутбуке работает так же, как и в облаке.
	- Переносимость облачных и операционных систем: работает на Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine и в любом другом месте.
	- Управление, ориентированное на приложения: повышает уровень абстракции от запуска ОС на виртуальном оборудовании до запуска приложения в ОС с использованием логических ресурсов.
	- Слабосвязанные, распределенные, гибкие, выделенные микросервисы: вместо монолитного стека на одной большой выделенной машине, приложения разбиты на более мелкие независимые части, которые можно динамически развертывать и управлять.
	- Изоляция ресурсов: предсказуемая производительность приложения.
	- Грамотное использование ресурсов: высокая эффективность и компактность.
	

10. Какова файловая структура в Linux (UNIX) системах, расположенных в */etc*, */dev*, */proc*, */sys*, */lib*, */var* (несколько директорий на выбор)?
	
	Файловая структура Linux - это иерархическая система, в которой каждый файл и каталог имеет уникальный путь. Некоторые из указанных директорий (например, `/proc`, `/sys`) доступны только для чтения, а некоторые (например, `/etc`) - только для записи с правами root. Файловая система Linux - это очень гибкая система, и ее структуру можно изменять в соответствии с потребностями.
	
	> [!info] `/etc`
	> **Назначение**: Содержит конфигурационные файлы системы.
	> **Структура**: Файлы и подкаталоги, содержащие настройки для различных служб, программ и драйверов.
	> `passwd`, `shadow`, `hosts`, `resolv.conf`, `fstab`, `crontab`, `init.d`, `network`, `X11`, `sysctl.conf`, `sysctl.d`, `profile`
	> 
	> > [!important] **Важно**:
	> > Файлы в `/etc` обычно редактируются с правами суперпользователя (root).
	> > Изменения в этих файлах могут повлиять на работу системы.
	> 
	
	> [!info] `/dev`
	> **Назначение**: Содержит файлы устройств, представляющие собой интерфейсы к аппаратным компонентам системы.
	> **Структура**: `sda`, `sdb`, `sdc` (диски), `tty1`, `tty2` (консоли), `null`, `zero`, `random`, `urandom`, `loop` (специальные устройства).
	> 
	> > [!important] **Важно**:
	> > Файлы в `/dev` - это не файлы в обычном смысле, а ссылки на устройства.
	> > Доступ к устройствам осуществляется через эти файлы.
	>
	
	> [!info] `/proc`
	> **Назначение**: Виртуальная файловая система, которая предоставляет информацию о текущем состоянии системы.
	> **Структура**: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/uptime`, `/proc/cmdline`, `/proc/mounts`, `/proc/net`, `/proc/sys`, `/proc/version`
	> 
	> > [!important] **Важно**:
	> > Файлы в `/proc` не являются "реальными" файлами, а представляют собой интерфейс к ядру Linux.
	> > Информация в `/proc` обновляется в реальном времени.
	>
	
	> [!info] `/sys`	
	> **Назначение**: Еще одна виртуальная файловая система, которая обеспечивает доступ к параметрам ядра.
	> **Структура**: `/sys/block`, `/sys/bus`, `/sys/class`, `/sys/devices`, `/sys/firmware`, `/sys/fs`, `/sys/kernel`, `/sys/module`, `/sys/power`
	> 
	> > [!important] **Важно**:
	> > `/sys` предоставляет более детальную информацию о ядре, чем `/proc`.
	> > Доступ к параметрам ядра через `/sys` позволяет настраивать систему без перезагрузки.
	>
	
	> [!info] `/lib`
	> **Назначение**: Содержит библиотеки программ, используемые другими программами.
	> **Структура**: `/lib/x86_64-linux-gnu`, `/lib/modules`, `/lib/system
	> 
	> > [!important] **Важно**:
	> > Библиотеки в `/lib` необходимы для запуска многих программ.
	> > Обычно программы не хранятся в `/lib`.
	>
	
	> [!info] `/var`
	> **Назначение**: Содержит переменные данные, такие как журналы, кэши, базы данных, временные файлы и т.д.
	> **Структура**: `/var/log`, `/var/cache`, `/var/lib`, `/var/mail`, `/var/tmp`, `/var/spool`, `/var/www`
	> 
	> > [!important] **Важно**:
	> > Данные в `/var` могут меняться во время работы системы.
	> > Обычно `/var` содержит более важные данные, чем `/tmp`, и его содержимое, как правило, не удаляется при перезагрузке системы.
	>
	

11. Что такое Load Average?
	
	— это показатель, который показывает среднюю нагрузку на сервер за определённый период времени. Под средней нагрузкой на сервер понимают суммарную нагрузку процессами на центральный процессор и подсистему ввода/вывода за определённый промежуток времени.
	Каждый раз, когда обнаруживается снижение производительности системы, первое, что обычно делается для диагностики — это запуск команд `htop`, `top`, `uptime` или `cat /proc/loadavg`, чтобы понять нагрузку на систему, например:
	
	```bash
	uptime
	01:43:15 up 3 days, 22:17, 1 user, load average: 0.51, 0.72, 0.86
	```
	
	Последние три числа в это выводе — это Load Average за последние ***1 минуту***, ***5 минут*** и ***15 минут***.
	
	> [!info] Под средней нагрузкой на сервер понимают суммарную нагрузку процессами на центральный процессор и подсистему ввода/вывода за определённый промежуток времени.
	> Этот показатель может сказать нам, когда наш сервер хорошо нагружен, совсем не нагружен или нагружен слишком сильно. Также, смотря на него можно понять, растёт ли нагрузка, снижается, или остаётся без изменений.
	
	**Load Average рассчитывается**
	
	Определяем количество ядер:
	
	```bash
	grep 'model name' /proc/cpuinfo | wc -l
	16
	
	top (then press 1)
	16
	
	nproc
	16
	```
	
	Максимальным пределом для Load Average обычно считается количество ядер на сервере, которые способны обрабатывать процессы. Например, если на сервере суммарно 16 ядер, то одновременно на нём может выполняться 16 процессов. И это означает, что если:
	- LA < 16, значит всё хорошо.
	- LA = 16, значит сервер работает без задержек, но запаса на нём уже нет.
	- LA > 16, процессам приходится ждать, значит сервер будет работать с задержками.
	
	Какие же процессы нагружают систему:
	- которые уже обрабатываются на процессоре (running);
	- только готовые обрабатываться (runnable);
	- обратившиеся к подсистеме ввода/вывода и читающие или пишущие туда информацию (uninterruptible sleep).
	
	Первые два вида процессов — это нагрузка на процессор, а последний — это нагрузка на подсистему ввода вывода (обычно нагрузка на диск или сетевой ресурс).
	
	Процессы, которые обрабатываются на процессоре, или готовы обрабатываться в выводе `ps` обозначаются статусом **R** (**running or runnable**). А процессы в состоянии **uninterruptible sleep** обозначаются буквой **D**. Посмотреть такие процессы в определённый момент времени, можно выполнив команду:
	
	```bash
	ps ax -o pid,comm,state | egrep 'D$|R$'
	   69 ps              R
	   70 egrep           D
	```
	
	А если хотите понаблюдать за изменениями, то воспользуйтесь утилитой `watch`.
	
	И не забывайте что **Load Average** — это среднее значение. Представим что за минуту процессор обработает 5 циклов (это не примерно, так просто легче считать):
	- 1 цикл — 2R
	- 2 цикл — 5R
	- 3 цикл — 2R + 1D
	- 4 цикл — 16R
	- 5 цикл -2R
	
	Получается что в этом случае **LA** = (2 + 5 + 3 + 16 + 2) / 5 = **5,6**. Для 16 ядерного процессора, вполне нормально. Но для 4 ядерного — плохо.
	
	Анализ значений Load Average:
	Если первое число больше чем второе и третье, значит нагрузка в данный момент растёт. И наоборот, если третье число самое большое, второе поменьше, а первое ещё меньше — значит нагрузка на сервере была высокой, но уже упала.
	
	Если значение **LA** меньше чем число ядер, значит сервер справляется со своими задачами. При этом могут быть недолгие колебания, когда **LA** становится больше числа ядер.
	А если **Load Average**, на протяжении всей работы сервера, равен количеству ядер сервера. Это значит, что сервер работает на пределе, но при этом справляется со своей работой. Проблема в этом случае заключается только в том, что нет запаса по производительности. Какое-то приложение на сервере обновится, или вы установите новое приложение и сервер начнёт подтормаживать. Поэтому, в этом случае, можно уже подумать над оптимизацией или апгрейдом сервера.
	Ну и если вы заметили что на вашем сервере средняя нагрузка выше чем его количество ядер. Значит сервер работает с тормозами. То есть одни процессы, постоянно ждут других и выполняются с запозданием. Значит пора менять сервер, или производить действия по его оптимизации.
	Также, бывают ситуации, при которых **Load Average** может резко начать подниматься. Например, **LA** может быть постоянно в районе 6, и вдруг поднимется до 100. Обычно такое случается, когда на сервере что-то пошло не по плану. Например, сервер обращается к сетевому ресурсу, а тот недоступен, при этом процессы уходят в состояние **uninterruptible sleep**, тем самым повышая **LA**.
	

12. В чем разница между soft и hard symlink?
	
	Основные различия при работе с soft и hard symlink:
	- hard symlink не может указывать на файл в другой файловой системе (так как inode может принадлежать только одной ФС), а soft symlink - может
	- при редактировании файла-ссылки в случае с hard symlink-ом - изменятся оба файла, так как это один и тот же объект, а в случае с soft symlink-а - можно изменять его имя, атрибуты, направить его на другой файл и при этом оригинальный файл не будет затронут (но нужно учитывать, что если открыть файл soft symlink для редактирования - то изменяться будет оригинальный файл, т.к. по сути открывается для редактирования именно он)
	- hard symlink не может указывать на каталог
	

13. Как работают file permissions, зачем директории права исполнения (`+x`)?

14. Что такое zombie process?

15. С помощью чего можно собрать информацию о текущем состоянии процессора, памяти, диска, сети?

16. Что такое *vm.swappiness*?

17. Как посмотреть свободное место на диске?

18. Что такое *inode*?
	
	это объект файловой системы, содержащий информацию о владельце/группе, которым принадлежит файл или каталог, его права доступа к нему, его размер, тип файла, timestamp-ы отражающие время модификации индексного дескриптора (ctime, changing time), время модификации содержимого файла (mtime, modification time) и время последнего доступа к файлу (atime, access time) и счётчик для учёта количества жёстких ссылок на файл. Каждый inode имеет собственный номер, который присваивается ему файловой системой в момент её создания (форматирования).
	
	```bash
	ls -lih | grep -
	4503599627395698 -rwxrwxrwx 1 av_zhivushko users  88K May 22 04:15 interview.md
	2533274790421046 -rwxrwxrwx 1 av_zhivushko users  101 Apr 30 09:53 README.md
	```
	
	Первая колонка как раз и отображает номер inode. Далее указываются права доступа, счётчик hardlink-ов на этот файл, права доступа и тип файла, пользователь, группа, размер, дата последней модификации файла и последним - его имя.
	

19. Расскажите поэтапно процесс загрузки Linux с момента включения питания компьютера.

20. Что произойдет при выполнении команд:

	1. `cat file1 > file2`
	
	2. `cat file1 >> file2`

21. В чем разница между *Ctrl+C* и *Ctrl+Z*?
	
	- `Ctrl+C` — если мы хотим завершить работу нашего сервера,
	- `Ctrl+Z` — если мы хотим приостановить и потом продолжить работу нашего сервера. (***запуск сервера приостановлен, а не завершен!** И из-за этого сервер каждый раз запускается на новом порту, если это предусмотрено в коде, или же будет выдавать ошибку, что тот порт уже занят! Возобновить работу можно с помощью команды: `fg`*)
	

22. Как перенаправить одновременно *stderr* и *stdin*?
	
	Стандартные потоки ввода и вывода в Linux являются одним из наиболее распространенных средств для обмена информацией процессов, а перенаправление `>`, `>>` и `|` является одной из самых популярных конструкций командного интерпретатора.
	Ввод и вывод распределяется между тремя стандартными потоками:
	- stdin — стандартный ввод (клавиатура),
	- stdout — стандартный вывод (экран),
	- stderr — стандартная ошибка (вывод ошибок на экран).
	
	Потоки также пронумерованы:
	- stdin — 0,
	- stdout — 1,
	- stderr — 2.
	
	В стандартном bash вы не можете одновременно перенаправить и `stderr` (`2`) и `stdin` (`0`) в один и тот же файл. Это связано с тем, что `>` перенаправляет только выходные данные.
	
	> [!faq] 1. Использование `&>`:
	>	Этот символ позволяет одновременно перенаправить `stdout` и `stderr` в один файл. Для перенаправления `stdin` нужно использовать `<<` с дескриптором файла:
	>	```bash
	>	cat <(echo "Входные данные") > output.txt 2>&1
	>	```  
	  
	> [!faq] 2. Использование `tee`:
	>	`tee` позволяет копировать выходные данные в файл и на стандартный вывод.
	>	```bash
	>	echo "Входные данные" | tee output.txt 2>&1
	>	```
	  
	> [!faq] 3. Использование `exec`:
	>	`exec` позволяет изменить стандартные потоки, включая `stdin`.
	>	```bash
	>	exec 0<input.txt # Перенаправление stdin из файла
	>	cat > output.txt 2>&1 # Перенаправление stdout и stderr в файл
	>	```
	
	> [!faq] `&>file` или `>&file` — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: `>file 2>&1`.
	

23. Как убить процесс? Какие есть типы сигналов?

24. Что делает команда `grep`?
	
	**— возвращает только строки, содержащие (или не содержащие) заданное регулярное выражение.**
	Используется для поиска строк в файлах, которые соответствуют заданному шаблону.
	
	Основные функции команды `grep`:
	* **Поиск текста:** `grep` может находить строки, содержащие заданный текст (например, `grep "hello" file.txt` найдет строки в файле `file.txt`, содержащие слово "hello").
	* **Использование регулярных выражений:** `grep` поддерживает использование регулярных выражений для более сложного поиска (например, `grep "h.*o" file.txt` найдет строки, начинающиеся с "h" и заканчивающиеся на "o").
	* **Выдача результатов:** `grep` может выводить найденные строки в консоль, а также выполнять дополнительные действия, такие как подсчет совпадений, вывод номеров строк, вывод только имен файлов, содержащих совпадения, и т.д.
	* **Обработка нескольких файлов:** `grep` может обрабатывать сразу несколько файлов, используя символ "`*`" (например, `grep "hello" *.txt` найдет все строки, содержащие "hello" во всех файлах с расширением .txt в текущей директории).
	
	Основные опции команды `grep`:
	* `-i`: Поиск без учета регистра  
	* `-v`: Вывод строк, *не* содержащих заданный шаблон  
	* `-n`: Вывод номеров строк, содержащих совпадения  
	* `-c`: Вывод только количества совпадений  
	* `-l`: Вывод имен файлов, содержащих совпадения  
	* `-w`: Совпадение только с целыми словами  
	* `-E`: Использование расширенных регулярных выражений
	

25. Что такое скрипт bash?

26. Какие типы переменных используются в bash?

27. Что выведут команды:

	1. `echo ${hostname};`
	
	2. `echo $(hostname);`

 
## Networks

28. Что такое модель OSI, TCP/IP?

29. Для чего нужны network masks?

30. Структура IP-пакета. Из чего состоит? Что такое фрагментация и почему она происходит?

31. Что такое коллизия? Почему возникает?

32. Что такое прокси?

33. Что такое firewalls и зачем они нужны?

34. Что такое NAT и для чего он нужен?

35. Какие типы IP-адресов вы знаете?

36. По какому порту и протоколу работают Ping и Traceroute?

 
## Clouds

37. В чем разница между IaaS, PaaS и SaaS?
	
	![IaaS_PaaS_SaaS](IaaS_PaaS_SaaS_v1.png)
	
	> [!info] IaaS — облачная инфраструктура как услуга
	> 
	> ![IaaS](IaaS.png)
	> 
	> это аренда виртуальной инфраструктуры: серверов, хранилищ данных и других вычислительных ресурсов.
	> При такой модели вы разворачиваете собственную инфраструктуру на чужих серверах: сами устанавливаете нужные системы и программы, настраиваете их под свои задачи, обеспечиваете защиту данных. Например, на облачную платформу Yandex Cloud компании переносят приложения, операционные системы, данные и управляют ими с помощью виртуальных машин. Провайдер отвечает только за доступ к системе и её работоспособность.
	
	> [!info] PaaS — облачная платформа как услуга
	> 
	> ![PaaS](PaaS.png)
	> 
	> готовая платформа с предустановленными настройками под конкретные задачи. PaaS часто используют разработчики, чтобы решать задачи быстро и эффективно. Эта облачная технология позволяет автоматизировать рутинные процессы, подключить инструменты разработки и тестирования.
	> Например, если вам нужна база данных, её не придётся создавать и разворачивать с нуля на удалённом сервере, как в случае с IaaS. Можно выбрать один из доступных вариантов на облачной платформе и загрузить туда свою информацию.
	> Однако, в отличие от IaaS, в сервисы PaaS не получится загрузить собственную операционную систему и с её помощью управлять серверами. Вендор предоставляет готовую к работе инфраструктуру с уже заданными параметрами и установленным ПО.
	
	> [!info] SaaS — облачное ПО как услуга
	> 
	> ![SaaS](SaaS.png)
	> 
	> полноценные программы в облаке, которые уже готовы к работе, для доступа к ним нужен только интернет. Вы пользуетесь готовым продуктом и не участвуете в разработке, настройке и техподдержке сервисов — эти обязательства берёт на себя поставщик.
	> К SaaS относятся мессенджеры, электронная почта, CRM-системы, сервисы видеозвонков, трекеры задач, конструкторы для создания сайтов и офисные программы.
	

38. Что такое VPC и из каких компонентов должно состоять?

39. Что такое cloud-init? init/systemd/upstart configs?

 
## Automation

40. Что такое Terraform?

41. Какие инструменты автоматизации вы знаете?

 
## Information Security

42. В чем разница между аутентификацией и авторизацией?

43. Сертификаты. Как работает HTTPS? Что такое certificate ciphers?

44. Как безопасно передать данные своему коллеге?

45. ​​Что такое MFA, TOTP?

 
## Виртуализация

46. В чем разница между виртуализацией и контейнеризацией? В чем плюсы и минусы?

47. Как при запуске Docker-контейнера «повесить» его из 80-го порта в контейнере на 8081 на хост?

48. Как передать в виртуальную машину USB device?

49. Docker-контейнер потребляет многие SWAP. Что делать?

 
## CI/CD

50. Какие существуют branching strategy? На что опираться при выборе?

51. Что такое Continuous Integration и Continuous Deployment? В чем разница между Continuous Deployment и Continuous Delivery?

52. Опишите основные этапы CI/CD.

53. Опишите пример процесса CI (и/или CD), который начинается с момента, когда разработчик запушил изменения/PR в Git?

54. Расскажите о разновидностях тестов, которые мы можем использовать в CI пайплайне.

55. Какие инструменты CI вы использовали? Есть ли опыт работы с Jenkinsfile?

56. Какие виды тестов вы знаете и зачем они нужны?

 
## Development

57. Git. Как решить merge conflict? Что такое `rebase`, `cherry-pick`?

58. В чем разница между `git merge` и `git rebase`?

59. Какие UI использовали?

60. Какая разница между GitLab/GitHub/Bitbucket?

61. Какая разница между `git pull`/`git fetch`?

62. Что такое Git-Flow?

63. Версионирование. Какая разница между SemVer и CalVer?

64. Тестирование. Какие существуют виды? Как писать тесты, TDD?

65. В чем разница между компилируемыми и интерпретационными языками программирования?

 
## Monitoring/Logging

66. Какие метрики нужно собирать? Разница между infrastructure и application monitoring.

67. Какая разница между pull и push model в системах мониторинга?

68. Какая разница между Black box и White box monitoring?

69. Расскажите о подходах к сбору application логов.

 
## Практические задания

71. Напишите простую программу на ваш выбор. Программа должна получать сообщения из сервиса очередей и печатать его в *stdout*. Сервис очередей — по вашему усмотрению.

72. Разберите структуру сервиса (на примере Docker-Compose).

73. Практическая сессия работы с Git (Git command line: `fetch`, `push`, `pull`, `rebase`, `checkout`, `submodules`).

 
# Middle

## Linux

1. Опишите архитектуру ядра Linux.

2. Что такое ядро ​​и каково его предназначение?

3. Опишите общие части файловой системы Unix/Linux, архитектуру файловой системы.

4. В чем разница между RedHat и Debian?

5. В чем разница между */proc* и */sys*?

6. Ситуация: указывает, что на диске занято 50% места, а сделать файл даже под root юзером не можем. В чем проблема?

7. Мы удалили файл, открывший приложение. Как нам его восстановить?

8. Как найти PID процесса, его стартовые параметры?

9. Как проверить, открыт ли порт на удаленном хосте, локальном хосте?

10. Как искать файл по его содержимому?

11. Что такое SSH, как организовать доступ на сервер без пароля или с определенных хостов? Как ограничить доступные для выполнения команды?

12. Как проверить потреблённые ресурсы во время сеанса SSH?

13. Что означает разрешение на файл 755?

14. Что такое SELinux и зачем он нужен?

15. Как определить PCI-устройство в системе, например, RAID controller?

16. Как переименовать устройство, например, сетевую карту или диск?

17. Что такое LVM? Какие знаете примеры использования?

18. Что такое root reserved space?

19. Что такое exit code и как его узнать?

20. Почему вывод `df -h` указывает, что на диске занято мало места, но система не дает записать файл с сообщением “no space left on device”?
	
	> [!faq]- **ошибка "No Space Left on Device"**
	> Иногда может возникнуть странная ситуация: с одной стороны - `df` или `du` будут говорить, что свободное место на диске есть, а с другой стороны операционная система будет утверждать, что "No Space Left on Device".
	> Одна из вероятных причин как раз является полное использование пула inode, выделенных для раздела на жёстком диске, т.к. количество inode фиксировано и задаётся во время создания таблицы раздела.
	> Проверить общее, занятое и доступное количество inode можно с помощью `df` и опции `-i`:
	> 
	> ```bash
	> df -i /dev/sdb
	> Filesystem       Inodes IUsed    IFree IUse% Mounted on
	> /dev/sdb       16777216 59921 16717295    1% /
	> ```
	> 
	> Тут для раздела `/dev/sdb` создано 16.777.216 inode, и это же является ограничением на количество файлов и директорий, которые можно будет создать на этом разделе (но есть ещё ограничения самой файловой системы).
	> 
	

21. В чем разница между `command1 & command2` и `command1 && command2`, а также `command1 && command2 || command3`?

22. Из сети резко вырос исходящий трафик на 25-й порт. Как, имея доступ на gateway, обнаружить вредителя из внутренней сети?

23. Как затюнить параметры Linux Kernel?

24. Что такое ulimits?

25. В чем разница между символическими и hard links?

26. Что такое фрагментация *ext3* и *ext4*?

27. Зачем файловые системы *ext\** резервируют 5% места?

28. Как увеличить размер файловой системы?

29. Можем ли мы уменьшить размер файловой системы?

30. Что такое `chroot` и для чего он нужен?

31. У нас есть Linux box с 2 Гб оперативной памяти и Java-приложение, которое пытается выделить 4 Гб во время запуска. Удастся ли это?

32. Есть приложение, которое читает файл, который пользователь пытается удалить. Что случится? Можно ли удалить этот файл? Можно ли восстановить этот файл?

33. Какие механизмы создания процессов в Linux вы знаете?

34. Сравните *systemd* и *init system*.

35. У вас есть папка с большим количеством файлов, и вы хотите удалить все файлы с именами, начинающимися на A (прописная буква). Но команда `rm –f A*` выдает Argument list too long. Как удалить эти файлы?

36. Вы начинаете удалять файлы первым методом из предыдущего вопроса, но каждый `rm` запрашивает подтверждение. Это очень долго. Как можно ускорить эту операцию?

 
## Networks

37. Расскажите о модели OSI. Опишите функции и назначение каждого уровня.

38. Какие сетевые топологии вы знаете? Опишите разницу между ними.

39. Зачем нужен IP-адрес, если MAC-адрес уникален? Разве мы не можем общаться только по MAC-адресу?

40. В чем разница между концентратором и коммутатором L2 в сетях Ethernet?

41. Что такое VLAN и для чего существует разделение на виртуальные локальные сети?

42. Какой номер порта используется для PING-коммуникации?

43. Что такое сеанс связи? Какой алгоритм использует TCP для доставки?

44. В чем основное отличие между TCP и UDP?

45. Зачем нам маршрутизатор по умолчанию?

46. Как хост решает DNS по умолчанию?

47. Компьютер начал получать IP-адрес из другой сети (есть подозрение, что в сети работает другой DHCP-сервер): как его найти и отключить? Какие методы защиты от такой проблемы?

48. Мы будем мигрировать сайт на новый IP-адрес. Как сделать, чтобы пользователи этого практически не заметили?

49. Что такое socket?

50. Как узнать, какие удаленные хосты подключаются к хосту через порт 8888? (с помощью команд и не используя */proc* или */sys*).

51. У нас есть несколько сетевых карт. Как увеличить пропускную способность сервера?

52. Как проверить открытые порты на удаленном сервере без команд Netcat или Nmap Linux?

 
## Container orchestration

53. В чем преимущества Kubernetes как платформы?

54. Что такое control plane и из каких компонентов состоит?

55. Какие CNI вы использовали и чем они отличаются?

56. Чем отличается managed Kubernetes от self-deployed?

57. Как можно контролировать размещение подов в кластере? (taints/tolerations, affinities, topologies etc.)

58. Скейлинг кластера. Cluster autoscaler vs HPA vs VPA? Как сделать zero-downtime node decommission/cluster upgrade? PDB? Lifecycle hooks?

59. Какие способы для внешнего доступа к кластеру? *ingress*, *node port*, *port-forward* и т. д.

60. С каким PID запускается процесс в контейнере?

61. Что лучше использовать для изоляции окружения – Vagrant или Docker?

62. Какой инструмент оркестрирования контейнеров использовали? (Swarm, Kubernetes, Openshift, Rancher и т. д.)

63. Что происходит в Kubernetes после запуска kubectl (API, ReplicaSet Controller, storage back-end, scheduler, kubelet, worker node, pod)?

64. Какая разница между pod и контейнером в K8s?

65. Как мы можем сделать любой микросервис, работающий на K8s, доступным из внешней среды?


## Виртуализация и контейнеризация

66. Какие типы виртуализации вы знаете?

67. Как работает Docker на macOS/Windows?

68. Что такое Docker-image и Docker-контейнер? Как они между собой связаны?

69. Каковы основные отличия между контейнерами докеров и виртуальными машинами?

70. Что такое image layer? Какое максимальное количество layers возможно? Почему нужно пытаться иметь малое количество layers? Какое оптимальное количество?

71. Как в виртуальной машине изменить размер диска после создания? Что нужно сделать с гостевой ОС?

72. Как в Docker реализовано ограничение ресурсов?

73. Существует виртуальная машина, к которой потерян доступ. Как, имея доступ к диску, восстановить root пароль/SSH-ключ?

74. Оптимизировать Dockerfile, объяснить, что и почему так:

```yaml
FROM golang
RUN apt install -y pkg1 pkg2 pkgN # Dependencies for app
COPY. .
RUN go build -o app main.go
CMD ./app
```

75. Что такое IPVS и какой у него функционал?

76. Какова структура API в Kubernetes?

77. Что такое operators и зачем они нужны?


## CI/CD

78. Какие стадии должны быть в любом пайплайне (lint, test, build, deploy etc.)?

79. Как и где хранить build artifacts?

80. Что такое артефакт?

81. Есть два бренча: dev и stage. Мы забросили Dockerfile в dev, а затем сбилдили в dev и stage. Это будет одним артефактом или разными?

82. Что вы использовали для автоматизации настройки Jenkins и GitLab CI?

83. Сравните CI инструментов: Jenkins, GitLab CI, AWS Code Pipeline, GCP cloudbuild, GitHub actions, Circle CI.

84. Deployment strategies. Какие существуют и чем отличаются (recreate, blue-green, canary etc.)?

85. Как реализовать СI/CD для программы, которая зависит от нескольких других программ?

86. GitOps. В чем его преимущества и недостатки?


## Clouds and Automation

87. Какова роль и преимущества облачных сервисов для DevOps?

88. Что такое immutable infrastructure? Как достичь? В чем преимущества и недостатки? Packer, AMI и т. д.

89. Структура Terraform. Как организовать multi-environment project? Terraform workspaces?

90. Лучшие практики по использованию многих Terraform states.

91. Как организовать доступ команде разработчиков к AWS/GCP/Azure? Role-based access, assume role, SSO.

92. Что такое Terraform provider, module?

93. Как версионировать Terraform modules?

94. Когда нужно использовать local-exec и remote-exec?

95. Что такое golden image и как его создать?

 
## Monitoring/Logging

96. Как мониторинг помогает поддерживать всю архитектуру системы?

97. Какие инструменты мониторинга вы использовали?

98. Что такое медиана и процентиль?

99. Что такое SLI, SLO, SLA? Зачем это нужно?

100. Архитектура системы для сбора логов, ELK, EFK etc. Как сохранить logs при отказе хранилища? Нужно ли использовать для этого брокер сообщений? Нужно ли делать throttling / rate limits?

101. Prometheus long-term storage. Какие варианты?

102. Как работает Prometheus?

103. В чем принципиальное отличие между Grafana и Kibana?

104. В чем главное отличие между *Ansible* and *Terraform*?

105. Что такое SAAS monitoring и какие виды знаете?

106. Если вы используете *Datadog* / *NewRelic*, то как нам отслеживать падение инструментов мониторинга?

107. Что такое distributed tracing и error tracking systems? Как вы думаете, когда следует их использовать?

 
## Information Security

108. В чем разница между *RBAC* и *ABAC*?

109. В чем заключается XSS атака? SQL injection? Что такое CSP?

110. Какие базовые меры можно предпринять для защиты SSH-соединения?

111. Root-пароль неизвестен или потерян. Какова процедура восстановления?

112. Как управлять правами на файловой системе в Linux?

113. Что такое Firewall?

114. Чем отличается stateless от stateful firewalls?

115. Сколько таблиц в `iptables`?

116. Можно ли настроить трансляцию NAT с помощью `iptables`? Какую таблицу следует использовать?

117. Какую таблицу используют для смены заголовков пакетов?

118. Если вам ломают Linux-сервер, то как более эффективно блокировать трафик с IP-адресов?

119. Принцип работы GCP Firewall: можем ли мы профильтровать трафик на Load Balancer?

120. Что такое SELinux?

121. Можно ли полностью отключить SELinux на лету?

122. С какими secrets management systems вы работали?

123. У нас есть сервер NAT, и мы хотим обеспечить доступ по IP к серверу снаружи. Как нам это реализовать?

123. Чтобы попасть на сервер клиента, нужно залогиниться на 4+ jump хоста. Как автоматизировать? Где мы будем хранить наш SSH-ключ?

 
## Development

125. Что такое cookies? Зачем нужны? JWT?

126. Что такое feature toggles и зачем они?

127. Что такое TDD (Test Driven Development) и BDD (Behavior Driven Development)?

 
## Databases

128. Что такое индекс и что такое ключ?

129. Каковы преимущества и недостатки индексов?

130. Представьте, что вы разрабатываете систему биллинга, которая должна обрабатывать тысячи счетов. Какую стратегию обновления данных вы бы выбрали?

131. Какие методы чаще всего используют для масштабирования реляционных баз данных?

132. Опишите механизм транзакций БД.

133. Как мы можем удалить таблицу или базу данных?

134. Как найти медленные запросы в MySQL/PostgreSQL?

135. Какие SQL-операторы манипулирования данными вы знаете?

136. Можно ли вывести список баз данных/таблиц через CLI? Как мы можем переключаться между базами данных MySQL/PostgreSQL?

137. Какие storage engines в MySQL вы знаете? Какие отличия?

138. Как реализована репликация MySQL master-master? Сколько серверов MySQL может быть задействовано в таком взаимодействии?

139. Как работает репликация MySQL/PostgreSQL? Какие параметры должны быть настроены для репликации?

140. Сравните SQL и NoSQL.

141. Sharding vs replication?

142. Какие есть виды индексов? Когда и зачем использовать?

143. Требования к схеме БД. Character sets, collations, default, not null и т. д.

144. Мы мигрируем MySQL/PostgreSQL из on-prem в облако. Как нам это сделать с минимальным downtime?

145. Зачем и как тестировать перформанс баз данных?

 
## Практические задания

146. Напишите Terraform module для инфраструктуры тестового сервиса в AWS.

147. Напишите hello-world программу на ваш выбор и сформируйте для нее *helm chart* / *helm kustomize*.

148. Как организовать deploy без downtime?

149. Опишите способы troubleshooting для Docker-контейнера.

150. Разобрать и объяснить структуру CI/CD pipeline (на примере `gitlab.yml`).

151. Продемонстрируйте навыки работы с GitOps, опишите deployment простенькой программы.

152. Как организовать deploy веб-приложения, запущенный на нескольких серверах без (или с минимальным) downtime?

153. Как с помощью Ansible узнать default gateway для пула серверов, и, если он отличается от желаемого, записать строчку «hostname: gateway» в файл на локальной машине?
